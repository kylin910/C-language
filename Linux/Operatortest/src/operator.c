/*
c语言中，常量、变量与运算符相结合可以构成各种各样的表达式。C语言的运算符不仅具有不同的优先级，而且还有一个特点，就是它的结合性。在表达式中，各参与运算的常量和变量不仅要遵守运算符优先级的规定，还要手运算符结合性的制约，以便确定是自左向右还是自右向左进行运算。C语言主要有如下这些运算符。
1.算数运算符(+,-,*,/,%,++,--)
2.赋值运算符(=)
3.逗号运算符(.)
4.类型转换运算符(0)
5.关系运算符(>,<,==,>=,<=,!=)
6.逻辑运算符(!,&&,||)
7.条件运算符(?:)
8.求字节运算符(sizeof)
9.指针运算符(*,&)
10.下标运算符([])
11.分量运算符(.,->)
12.位运算符(>>,>>,~,|,^,&)
本节将介绍前4种运算符及其相应的表达式，第5、6、7三种运算符将在第3章介绍，第8种运算符在2.2解已经介绍过其使用方法，第9、10种运算符将在第4章的指针和数组部分加以介绍，第11种运算符将在第5章的结构体部分介绍其使用方法。第12种运算符由于在应用编程中一般不使用，本书不作介绍，有兴趣的读者可以参考其他资料。C语言中运算符初看似乎很多，但熟练之海就会非常简单且容易使用。

算数运算符与算数表达式
1.基本算术运算符
+:加法运算符，如4+8,a+10,这里a是一个变量，下同。
-:减法运算符，如4-8,a-10,-a
*:乘法运算符，如4*8,a*10
/:除法运算符，如4/8,a/10
%:求余运算符，如7%3，则值为1
这里要注意：
1)括号也可以参与运算，如a*(4+8)
2)两个整数相除，结果仍然是整数，如5/3的结果是1,小数部分将舍去。
3)求余运算符的两边都应为整数，如7.5%3是没有意义的
4)当整型(int,short,long)、浮点型(float,double)、字符型(char)数据混合运算时，不同类型的数据先转换为同一类型，然后再进行运算。其中short和char类型将自动转换为int类型，float类型将自动转换为double类型进行运算。如考虑以下表达式。
1.a+'A',假设a是一个int类型的变量，值为1000,'A'是一个字符型常量，两者运算时，'A'将转换为int类型，运算结果是int类型。那么'A'是如何转换为int类型的呢？'A'在内存中是以它的ASCII码值65的二进制形式存放的，占1个字节，而int是4字节的，运算时用4个字节来存储'A'的值65，最低一个字节仍然存放65的二进制数，高出的3个字节将以0来填充。最后运算结果为1065。
2.a+b，假设a和b都是float型，则运算时，系统自动把a和b都扩充为8个字节的double型进行运算，产生结果后又把结果转换回float型，因此结果仍然为float型。若float型的数与double型的数进行运算则结果为double型。
3.100+'A'-65.25，这个表达式有int型100、char型'A'、float型65.25，则运算时char型数'A'自动转换为int型，既有int型也有float型时，int型将转换为float型进行运算，而float型在运算时会自动转换为double型，所以这3个量都转换为double型参与运算，最后系统把结果转换回float型。系统相当于进行如下运算100.0+65.0-65.25，运算结果为100.25。

2.算数运算符和表达式的优先级和结合型
在表达式中，优先级较高的先于优先级较低的进行运算，而在一个运算量两侧的运算符优先级相同时，则按运算符的结合性所规定的结合方向处理。C语言中各运算符的结合性分为两种，即左结合性（自左至右）和右结合性（自右至左）。例如算数运算符的结合性是自左至右，即先左后右。如有表达式x-y+z则y应先与“-”号结合，执行x-y运算，然后再执行加z的运算。这种自左至右的结合方向就称为“左结合性”。而自右至左的结合方向称为“右结合性”。最典型的右结合性运算符是赋值运算符，如有赋值表达式x=y=z，由于赋值运算符"="的右结合性，应先执行y=z，即把z值赋给y，再执行x=y运算，即把y的值赋给x。C语言运算符中有少量运算符为右结合性，应注意区别，以避免理解错误。
3.强制类型转换
可以利用强制类型转换符“()”将表达式或常量、变量转换为所需类型，例如：
(double)a:将变量a的值转换为double型。
(int)x+y:将变量x的值转换为int型再与y进行运算。
(int)(x+y):将x+y的结果转换为int型。
(float)(11%5):将11%5的结果转换为float型。
注意:在进行强制类型转换时，得到的是一个所需的中间类型，原来变量的类型并未发生变化，例如：
double a=3.141592;
int i=(int)a;
则i的值为3,而a的值仍然为3.141592。
4.自增运算符++和自减运算符--
自增1运算符“++”,其功能是使变量的值自增1。自减1运算符“--”，其功能是使变量值自减1。自增，自减运算符均为右结合性。它可以有以下几种形式。
i++:先使用i，再把i的值加1
i--:先使用i，再把i的值减1
++i:先把i的值加1,再使用i
--i:先把i的值减1,再使用i
例2-6将实现自增运算符和自减运算符的功能。
*/

#include <stdio.h>
int main(){
	int i=3,j,k;
	j=i++;
	k=++i;
	
	printf("i=%d,j=%d,k=%d\n",i,j,k);
	printf("%d\n",-i++);
	printf("%d,%d,%d",i,i++,i++);
}
/*
程序说明。
1)程序首先定义了3个变量i,j,k,并为变量i赋予初值3。
2)第二条语句，先引用i的值，再将i加1,等价于"j=i;i=i+1;"。第三条语句，先将i加1,再引用i的值，等价于"i=i+1;j=i;"。结果i,j,k分别输出5,3,5。
3)第二条打印语句中，表达式"-i++"相当于"-(i++)"即先引用i的值，则-i等于-5，结果输出-5，之后i的值加1,所以该语句执行完毕后i的值已变为6。
4)第三条语句打印出什么呢，“6,7,8”?事实上打印出的是8,7,6。因为printf中i，i++，i++的求值比较特殊，它是从右往左求值的。也就是先求最右边的i++，此时先引用i的值6,之后i的值加1变为7,然后是中间的i++,先引用i的值7，然后把i的加1使之变为8，最后是左边的i,此时i的值是8。
5)++，--运算符只能对单个变量起作用，对表达式和常量是不起作用的。如"(a+b)++"，原意是先将a和b的值相加，再把结果加1,但++操作的对象是表达式（a+b），所以该表达式的错误的。又如8++,也是错误的，因为8是常量。要验证程序是否可以含有(a+b)++这样的表达式，可以写一个测试程序，其中含有类似的表达式，可以发现编译器在编译时会报告错误。
程序运行结果：
i=5,j=3,k=5
-5
8,7,6

赋值运算符与赋值表达式
1.基本的赋值运算符"="
赋值运算符"="在前面的程序中已经基本介绍过它的使用方法了。它的一般形式是：
变量=表达式;
它首先计算表达式的值，再把值赋给变量。例如:
a=b=8;把8赋给b，再把变量b的值赋给a,a的值也为8。
a=3+(b=7);把7赋给b，然后计算3+b的值，最后把结果10赋给a。
a=(b=5)/(c=3);把5和3分别赋给b和c后，计算b/c，把结果1赋给a,这里假定a、b、c为int型。
如果赋值运算符两边的数据类型不相同，系统将自动进行类型转换，即把赋值号右边的类型转换为左边的类型。具体规定如下。
1)实型赋给整型，舍去小数部分。如有语句"int a=3.14;"则a的值为3。
2)整型赋给实型，数值不变，但将以浮点形式存放，即增加小数部分（小数部分的值为0）。如有语句"float a=15;"则a的值为15.000000。
3)字符型数据赋给整型数据，由于字符型为1个字节，而整型为4个字节，故将字符的ASCII码值放到整型量的最低的8位中，高位的3个字节为0。
4)整型赋给字符型，只把低8位赋予字符变量。由于char只有一个字节，而int为4个字节，赋值时只把int型变量的值的最低8位赋给字符变量，高出的24位舍去。
2.复合的赋值运算符
复合赋值符主要有+=、-=、*=、/=、%=。例如:
int a=10;
a+=5;
第二条相当于"a=a+5"其他的复合赋值符也一样。要注意的是:
x*=y+8;
它等价于"x=x*(y+8)";而不是"x=x*y+8;",其他的复合赋值符也一样。
2.3.3 逗号运算符与逗号表达式
c语言中逗号","也是一种运算符，称为逗号运算符。其功能是把几个表达式连接起来组成一个表达式，称为逗号表达式。它的一般形式是:
表达式1,表达式2,……,表达式a
其求值过程是从左到右分别求出这n个表达式的值，并以表达式n的值作为整个逗号表达式的值。如有以下语句：
int a=(3*5,6+9,30);
先计算括号内逗号表达式的值，该逗号表达式的值为30,再把30赋给变量a，结果a的值为30。
逗号表达式的运算优先级是最低的，赋值运算符的优先级高于它。如有以下程序代码:
int a=5;
a=(a=3*5,a*4),a+5;
那么最后a的值是多少呢？第二条语句可以分为两部分,"a=(a=3*5,a*4)"和"a+5",先算左边，再计算右边。因为逗号运算符的优先级最低，所以最外面的逗号是最后求值的。“a=(a=3*5,a*4)”中先求括号中的部分"a=3*5,a*4"。"a=3*5,a*4"中又先计算"a=3*5",此时a等于15,经过"a*4"后，a值变为60。再把60赋给a。最后计算"a+5"，“a+5”的运算对a的值没有影响，a只是加了5而没有把加后的结果赋给a，所以对a没有影响。最后a的值是60。
*/

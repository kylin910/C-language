/*
指针和函数：
1.指针作为函数的参数
函数的参数不仅可以是整型、字符型、实型也可以是指针类型。它的作用是将一个变量的地址传送到一个函数中，下面的实例演示了作为函数的参数的功能实现。	
*/
#include <stdio.h>

void change(int i,int *p){
	i++;
	if(p!=NULL){
		(*p)++;
	}
}
int main(){
	int a=5,b=10;
	change(a,&b);
	printf("a=%d b=%d",a,b);
	return 0;
}
/*
程序说明：
函数change接收两个参数，一个为整型，一个为指向整型变量的指针。在函数中，语句(*p)++对p所指向的变量执行加1操作。在主函数中调用了change函数，其中一个实参为变量a，另一个实参为变量b的地址。因为change函数的第二个参数为指针，所以必须传递一个变量地址。对于指针型形参，实参也可以是NULL,因此change函数中必须检查p是否为NULL。如果实参为NULL，那么语句(*p)++将导致程序崩溃。
从程序的运行结果，可以看到主函数中调用change函数后变量b的值改变了，而变量a没有改变。为什么会这样呢？函数的参数是局限于该函数的局部变量。函数调用时，系统为函数的局部变量分配内存。在主函数中调用change函数时，系统分配8个字节的内存，4字节用于保存变量i的值，另外4字节保存指针变量p的值。变量i保存的是数值5,而指针变量p保存的是变量b的地址。change函数中语句i++并不作用于变量a，而仅仅作用于刚刚分配的4字节存储空间，此时i的值为6而a的值依然为5。而对于语句(*p)++,p保存的是变量b的地址，*p的含义是系统根据该地址找到变量b，然后对它执行加1操作，变量b的值就变为11了。函数调用结束后，即主函数执行完语句change(a,&b)，调用函数时分配的内存就被系统回收了。
注意:如果一个函数的参数中有指针，那么出于程序健壮性的考虑，在该函数中须检查参数是否为NULL。

*/
